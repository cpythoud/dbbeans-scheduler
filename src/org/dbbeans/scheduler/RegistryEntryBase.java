// Generated by BeanMaker, on April 1, 2018 1:58:08 AM CEST
// Library Version #0.9.12-beta

package org.dbbeans.scheduler;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import org.beanmaker.util.BeanInternals;
import org.beanmaker.util.DBQueries;
import org.beanmaker.util.DbBeanInterface;
import org.beanmaker.util.ErrorMessage;
import org.beanmaker.util.IdNamePair;
import org.beanmaker.util.ToStringMaker;

import org.dbbeans.sql.DBQueryRetrieveData;
import org.dbbeans.sql.DBQuerySetup;
import org.dbbeans.sql.DBQuerySetupProcess;
import org.dbbeans.sql.DBTransaction;

import org.dbbeans.sql.queries.BooleanCheckQuery;

import org.dbbeans.util.Strings;

public abstract class RegistryEntryBase extends DbBean implements DbBeanInterface {
	private long id;
	private String code = "";
	private long idType;
	private boolean active;

	protected static final String DATABASE_TABLE_NAME = "schdlr_registry_entries";
	protected static final String DATABASE_FIELD_LIST = "schdlr_registry_entries.id, schdlr_registry_entries.code, schdlr_registry_entries.id_type, schdlr_registry_entries.active";

	protected final BeanInternals registryEntryInternals = new BeanInternals("org-dbbeans-scheduler-RegistryEntry");
	protected static final RegistryEntryParameters REGISTRY_ENTRY_PARAMETERS = new RegistryEntryParameters();

	public RegistryEntryBase() { }

	public RegistryEntryBase(final long id) {
		setId(id);
	}

	public RegistryEntryBase(final RegistryEntryBase registryEntryModel) {
		id = 0;
		code = registryEntryModel.code;
		idType = registryEntryModel.idType;
		active = registryEntryModel.active;
	}

	protected RegistryEntryBase(final long id, final String code, final long idType, final boolean active) {
		this.id = id;
		this.code = code;
		this.idType = idType;
		this.active = active;
	}

	protected RegistryEntryBase(final ResultSet rs) throws SQLException {
		this(rs.getLong(1), rs.getString(2), rs.getLong(3), rs.getBoolean(4));
	}

	@Override
	public void setId(final long id) {
		class DataFromDBQuery implements DBQuerySetupProcess {
			String code = null;
			long idType = 0;
			boolean active = false;
			boolean idOK = false;

			@Override
			public void setupPreparedStatement(final PreparedStatement stat) throws SQLException {
				stat.setLong(1, id);
			}

			@Override
			public void processResultSet(final ResultSet rs) throws SQLException {
				if (rs.next()) {
					code = rs.getString(1);
					idType = rs.getLong(2);
					active = rs.getBoolean(3);
					idOK = true;
				}
			}
		}

		if (id <= 0)
			throw new IllegalArgumentException("id = " + id + " <= 0");

		final DataFromDBQuery dataFromDBQuery = new DataFromDBQuery();
		dbAccess.processQuery("SELECT code, id_type, active FROM schdlr_registry_entries WHERE id=?", dataFromDBQuery);

		if (!dataFromDBQuery.idOK)
			throw new IllegalArgumentException("id = " + id + " does not exist");

		initExtraDbActions(id);

		this.id = id;
		this.code = dataFromDBQuery.code;
		this.idType = dataFromDBQuery.idType;
		this.active = dataFromDBQuery.active;

		postInitActions();
	}

	protected void initExtraDbActions(final long id) { }

	protected void postInitActions() { }

	@Override
	public void resetId() {
		id = 0;
	}

	public void refreshFromDataBase() {
		if (id == 0)
			throw new IllegalArgumentException("Cannot refresh bean not yet commited to database");

		setId(id);
	}

	@Override
	public boolean equals(final Object object) {
		if (id == 0)
			return false;

		if (object instanceof RegistryEntry)
			return ((RegistryEntry) object).getId() == id;

		return false;
	}

	@Override
	public int hashCode() {
		if (id == 0)
			return -1;

		return 31 * ((int) (id ^ (id >>> 32))) + 17;
	}

	@Override
	public String toString() {
		final ToStringMaker stringMaker = new ToStringMaker(this);
		stringMaker.addField("code", code);
		stringMaker.addField("idType", idType);
		stringMaker.addField("active", active);
		return stringMaker.toString();
	}

	public void setCode(final String code) {
		this.code = code;
	}

	public void setIdType(final long idType) {
		this.idType = idType;
	}

	public void setType(final RegistryEntryType type) {
		if (type.getId() == 0)
			throw new IllegalArgumentException("Cannot accept uninitialized RegistryEntryType bean (id = 0) as argument.");

		idType = type.getId();
	}

	public void setActive(final boolean active) {
		this.active = active;
	}

	@Override
	public long getId() {
		return id;
	}

	public String getCode() {
		return code;
	}

	public long getIdType() {
		return idType;
	}

	public RegistryEntryType getType() {
		return new RegistryEntryType(idType);
	}

	public boolean isActive() {
		return active;
	}

	public String getActiveVal() {
		if (active)
			return registryEntryInternals.getLabel("true_value");

		return registryEntryInternals.getLabel("false_value");
	}

	public String getCodeLabel() {
		return registryEntryInternals.getLabel("code");
	}

	public String getIdTypeLabel() {
		return registryEntryInternals.getLabel("idType");
	}

	public String getActiveLabel() {
		return registryEntryInternals.getLabel("active");
	}

	public boolean isIdRequired() {
		return true;
	}

	public boolean isCodeRequired() {
		return true;
	}

	public boolean isIdTypeRequired() {
		return true;
	}

	public boolean isActiveRequired() {
		return true;
	}

	public boolean isIdToBeUnique() {
		return true;
	}

	public boolean isCodeToBeUnique() {
		return true;
	}

	public boolean isIdTypeToBeUnique() {
		return false;
	}

	public boolean isActiveToBeUnique() {
		return false;
	}

	@Override
	public void updateDB() {
		preUpdateConversions();

		if (id == 0) {
			createRecord();
			return;
		}

		if (id > 0) {
			updateRecord();
			return;
		}

		assert (false) : "id < 0 ?!?";
	}

	public long updateDB(final DBTransaction transaction) {
		if (REGISTRY_ENTRY_PARAMETERS.USE_CACHE)
			throw new UnsupportedOperationException("Cannot cache intermediate updates.");

		preUpdateConversions(transaction);

		if (id == 0) {
			id = createRecord(transaction);
			return id;
		}

		if (id > 0) {
			updateRecord(transaction);
			return id;
		}

		assert (false) : "id < 0 ?!?";
		return -1;
	}

	@Override
	public void preUpdateConversions() {
		preUpdateConversions(null);
	}

	protected void preUpdateConversions(final DBTransaction transaction) {
		if (!isDataOK(transaction))
			throw new IllegalArgumentException(ErrorMessage.toStrings(getErrorMessages()));

	}

	@Override
	public boolean isDataOK() {
		return isDataOK(null);
	}

	protected boolean isDataOK(final DBTransaction transaction) {
		registryEntryInternals.clearErrorMessages();
		boolean ok = true;

		ok = checkDataForCode() && ok;
		ok = checkDataForIdType(transaction) && ok;

		return ok;
	}

	protected boolean checkDataForCode() {
		if (isCodeEmpty()) {
			if (isCodeRequired()) {
				registryEntryInternals.addErrorMessage(id, "code", getCodeLabel(), getCodeEmptyErrorMessage());
				return false;
			}
		} else if (!isCodeOK()) {
			registryEntryInternals.addErrorMessage(id, "code", getCodeLabel(), getCodeBadFormatErrorMessage());
			return false;
		} else if (isCodeToBeUnique() && !isCodeUnique()) {
			registryEntryInternals.addErrorMessage(id, "code", getCodeLabel(), getCodeNotUniqueErrorMessage());
			return false;
		}

		return true;
	}

	protected boolean checkDataForIdType() {
		return checkDataForIdType(null);
	}

	protected boolean checkDataForIdType(final DBTransaction transaction) {
		if (isIdTypeEmpty()) {
			if (isIdTypeRequired()) {
				registryEntryInternals.addErrorMessage(id, "idType", getIdTypeLabel(), getIdTypeEmptyErrorMessage());
				return false;
			}
		} else if (!isIdTypeOK(transaction)) {
			registryEntryInternals.addErrorMessage(id, "idType", getIdTypeLabel(), getIdTypeBadFormatErrorMessage());
			return false;
		} else if (isIdTypeToBeUnique() && !isIdTypeUnique()) {
			registryEntryInternals.addErrorMessage(id, "idType", getIdTypeLabel(), getIdTypeNotUniqueErrorMessage());
			return false;
		}

		return true;
	}

	public boolean isCodeEmpty() {
		return Strings.isEmpty(code);
	}

	public boolean isIdTypeEmpty() {
		return idType == 0;
	}

	public String getCodeEmptyErrorMessage() {
		return registryEntryInternals.getRequiredErrorMessage("code");
	}

	public String getIdTypeEmptyErrorMessage() {
		return registryEntryInternals.getRequiredErrorMessage("idType");
	}

	public boolean isCodeOK() {
		return true;
	}

	public boolean isIdTypeOK() {
		return isIdTypeOK(null);
	}

	protected boolean isIdTypeOK(final DBTransaction transaction) {
		if (transaction == null)
			return RegistryEntryType.isIdOK(idType);

		return RegistryEntryType.isIdOK(idType, transaction);
	}

	public String getCodeBadFormatErrorMessage() {
		return registryEntryInternals.getBadFormatErrorMessage("code");
	}

	public String getIdTypeBadFormatErrorMessage() {
		return registryEntryInternals.getBadFormatErrorMessage("idType");
	}

	public boolean isCodeUnique() {
		return !dbAccess.processQuery("SELECT id FROM schdlr_registry_entries WHERE code=? AND id <> ?", new BooleanCheckQuery() {
			@Override
			public void setupPreparedStatement(final PreparedStatement stat) throws SQLException {
				stat.setString(1, code);
				stat.setLong(2, id);
			}
		});
	}

	public boolean isIdTypeUnique() {
		return !dbAccess.processQuery("SELECT id FROM schdlr_registry_entries WHERE id_type=? AND id <> ?", new BooleanCheckQuery() {
			@Override
			public void setupPreparedStatement(final PreparedStatement stat) throws SQLException {
				stat.setLong(1, idType);
				stat.setLong(2, id);
			}
		});
	}

	public String getCodeNotUniqueErrorMessage() {
		return registryEntryInternals.getNotUniqueErrorMessage("code");
	}

	public String getIdTypeNotUniqueErrorMessage() {
		return registryEntryInternals.getNotUniqueErrorMessage("idType");
	}

	@Override
	public List<ErrorMessage> getErrorMessages() {
		return registryEntryInternals.getErrorMessages();
	}

	@Override
	public void reset() {
		code = "";
		idType = 0;
		active = false;
		registryEntryInternals.clearErrorMessages();
	}

	@Override
	public void fullReset() {
		reset();
		id = 0;
	}

	@Override
	public void delete() {
		final DBTransaction transaction = createDBTransaction();
		delete(transaction);
		transaction.commit();

		postDeleteActions();

		if (REGISTRY_ENTRY_PARAMETERS.USE_CACHE)
			REGISTRY_ENTRY_PARAMETERS.CACHE_SET.delete(id);

		fullReset();
	}

	public void delete(final DBTransaction transaction) {
		preDeleteExtraDbActions(transaction);
		transaction.addUpdate("DELETE FROM schdlr_registry_entries WHERE id=?", new DBQuerySetup() {
				@Override
				public void setupPreparedStatement(final PreparedStatement stat) throws SQLException {
					stat.setLong(1, id);
				}
			});
		deleteExtraDbActions(transaction);
	}

	protected void preDeleteExtraDbActions(final DBTransaction transaction) { }

	protected void deleteExtraDbActions(final DBTransaction transaction) { }

	protected void postDeleteActions() { }

	private class RecordCreationSetup implements DBQuerySetup {
		@Override
		public void setupPreparedStatement(final PreparedStatement stat) throws SQLException {
			stat.setString(1, code);
			stat.setLong(2, idType);
			stat.setBoolean(3, active);
		}
	}

	private class RecordUpdateSetup extends RecordCreationSetup {
		@Override
		public void setupPreparedStatement(final PreparedStatement stat) throws SQLException {
			super.setupPreparedStatement(stat);
			stat.setLong(4, id);
		}
	}

	private void createRecord() {
		final DBTransaction transaction = createDBTransaction();
		id = createRecord(transaction);
		transaction.commit();
		postCreateActions();
		updateCaching();
	}

	private long createRecord(final DBTransaction transaction) {
		preCreateExtraDbActions(transaction);
		final long id = transaction.addRecordCreation("INSERT INTO schdlr_registry_entries (code, id_type, active) VALUES (?, ?, ?)", new RecordCreationSetup());
		createExtraDbActions(transaction, id);
		return id;
	}

	protected void preCreateExtraDbActions(final DBTransaction transaction) { }

	protected void createExtraDbActions(final DBTransaction transaction, final long id) { }

	protected void postCreateActions() { }

	private void updateRecord() {
		final DBTransaction transaction = createDBTransaction();
		updateRecord(transaction);
		transaction.commit();
		postUpdateActions();
		updateCaching();
	}

	private void updateRecord(final DBTransaction transaction) {
		preUpdateExtraDbActions(transaction);
		transaction.addUpdate("UPDATE schdlr_registry_entries SET code=?, id_type=?, active=? WHERE id=?", new RecordUpdateSetup());
		updateExtraDbActions(transaction);
	}

	protected void preUpdateExtraDbActions(final DBTransaction transaction) { }

	protected void updateExtraDbActions(final DBTransaction transaction) { }

	protected void postUpdateActions() { }

	private void updateCaching() {
		if (REGISTRY_ENTRY_PARAMETERS.USE_CACHE)
			REGISTRY_ENTRY_PARAMETERS.CACHE_SET.submit((RegistryEntry) this);
	}

	public static List<RegistryEntry> getAll() {
		return getAll(REGISTRY_ENTRY_PARAMETERS.getOrderByFields());
	}

	protected static List<RegistryEntry> getAll(final String orderBy) {
		return getSelection(null, orderBy, null);
	}

	private static class GetSelectionQueryProcess implements DBQueryRetrieveData<List<RegistryEntry>> {
		@Override
		public List<RegistryEntry> processResultSet(final ResultSet rs) throws SQLException {
			final List<RegistryEntry> list = new ArrayList<RegistryEntry>();

			while (rs.next())
				list.add(new RegistryEntry(rs.getLong(1), rs.getString(2), rs.getLong(3), rs.getBoolean(4)));


			return list;
		}
	}

	protected static List<RegistryEntry> getSelection(final String whereClause) {
		return getSelection(whereClause, null);
	}

	protected static List<RegistryEntry> getSelection(final String whereClause, final DBQuerySetup setup) {
		return getSelection(whereClause, REGISTRY_ENTRY_PARAMETERS.getOrderByFields(), setup);
	}

	protected static List<RegistryEntry> getSelection(final String whereClause, final String orderBy, final DBQuerySetup setup) {
		if (whereClause == null && setup != null)
			throw new IllegalArgumentException("Cannot accept setup code without a WHERE clause.");

		final StringBuilder query = new StringBuilder();
		query.append("SELECT id, code, id_type, active FROM schdlr_registry_entries");
		if (whereClause != null)
			query.append(" WHERE ").append(whereClause);
		if (orderBy != null)
			query.append(" ORDER BY ").append(orderBy);

		if (whereClause == null || setup == null)
			return dbAccess.processQuery(query.toString(), new GetSelectionQueryProcess());

		return dbAccess.processQuery(query.toString(), setup, new GetSelectionQueryProcess());
	}

	private static class GetSelectionCountQueryProcess implements DBQueryRetrieveData<Long> {
		@Override
		public Long processResultSet(final ResultSet rs) throws SQLException {
			rs.next();
			return rs.getLong(1);
		}
	}

	protected static long getSelectionCount(final String whereClause) {
		return getSelectionCount(whereClause, null);
	}

	protected static long getSelectionCount(final String whereClause, final DBQuerySetup setup) {
		final String query = "SELECT COUNT(id) FROM schdlr_registry_entries WHERE " + whereClause;

		if (setup == null)
			return dbAccess.processQuery(query, new GetSelectionCountQueryProcess());

		return dbAccess.processQuery(query, setup, new GetSelectionCountQueryProcess());
	}

	public static List<IdNamePair> getIdNamePairs(final List<String> dataFields, final List<String> orderingFields) {
		return getIdNamePairs(null, dataFields, orderingFields);
	}

	protected static List<IdNamePair> getIdNamePairs(final String whereClause, final List<String> dataFields, final List<String> orderingFields) {
		return DBQueries.getIdNamePairs(db, "schdlr_registry_entries", whereClause, dataFields, orderingFields);
	}

	public static long getCount() {
		return DBQueries.getLongCount(db, "schdlr_registry_entries");
	}

	public static boolean isIdOK(final long id) {
		return DBQueries.isIdOK(db, "schdlr_registry_entries", id);
	}

	public static boolean isIdOK(final long id, final DBTransaction transaction) {
		return DBQueries.isIdOK(transaction, "schdlr_registry_entries", id);
	}

	public static String getHumanReadableTitle(final long id) {
		if (id == 0)
			return "";

		return DBQueries.getHumanReadableTitle(db, "schdlr_registry_entries", id, REGISTRY_ENTRY_PARAMETERS.getNamingFields());
	}

	public static List<RegistryEntry> getList(final ResultSet rs) throws SQLException {
		final List<RegistryEntry> list = new ArrayList<RegistryEntry>();

		while (rs.next())
			list.add(new RegistryEntry(rs));


		return list;
	}

	@Override
	public void setLocale(final Locale locale) {
		registryEntryInternals.setLocale(locale);
	}

}

